# Archiver

  Прочитал текст статьи, который вы скинули. Разобрал алгоритм построения дерева алфавита текста. Далее возник вопрос: *"А что если файл не текстовый?"*<br />
  Решил считывать байты из файла и строить дерево на байтах. (Чем больше раз определенный байт встречается, тем меньше у него длина кодирования в битах). 
  Далее алгоритм не вызывал вопросов, однако, когда начал проводить первые тесты заметил, что например тексты состоящие почти на 100% из кириллицы после архивирования увеличивали размер в несколько раз. 
(Архивированный файл укладывал в бинарник и создавал `txt` файл для хранение MAP <байт,кодировка(в битовой строке)>. Что касается прочих файлов, они в принципе успешно сжимались, но размер уменьшался максимум на 5%<br />
**В итоге: cомнительный результат**

  Решил все же написать алгоритм только для текстовых файлов. Тут же все получилось куда успешнее. Файлы `.txt` успешно сжимались и значительно уменьшали свои размеры.
В связи со всеми мучениями структура проекта оставляет желать лучшего (пока что)
Далее распишу по пакетам и классам структуру:

***Package Classes***<br />
Тут реализация архивации на байтах<br /><br />
- **Class Node** - звено дерева (содержит вес, значение, булевую переменную, которая указывае есть ли еще потомки, а также ссылки на самих потомков(если они есть)
- **Class HuffmanTree** - собственно само дерево, которое строится на основе списка.
- **Class Archivator** - собственно главный класс, в котором реализованы методы архивирования и разархивирования. На вход методу compress дается строка с адресом файла,который нужно заархивировать. После архивации
создается два файла: 
maps.txt - тут хранятся ключи и значения для разархивации, а также в первых символах необходимая информация
zipped.bin -  сжатый файл в формате бинарного файла
У метода extract нет параметров и он по дефолту работает только с файлами zipped.bin и maps.txt (позже приведу впроядок, т.к  пока не уверен в правильности реализации), а на выходе дает файл original1.<расширение исходного файла>
- Class TreeList - рудимент, первый вариант HuffmanTree, тут я писал структуру с нуля, а потом понял что проще реализовать на списке.<br />

***Package TempClasses***<br />
Тут реализация архивации на символах<br /><br />
- **Class NodeChar** - аналогичен классу Node в .Classes
- **Class HuffmanTreeChar** - аналогичен классе HuffmanTree в .Classes
- **Class ArchivatorChar** - впринципе тоже самое заисключением того, что Мапу и необходимую информацию пришлось хранить по другому (в 3 файлах). С этим я потом разберусь


***P.S Class Main - можно даже не смотреть***
